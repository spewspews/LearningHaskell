\documentclass{article}

\usepackage[paperwidth=5.5in,paperheight=8.5in,margin=0.5in,footskip=.25in]{geometry}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{unicode-math}
\usepackage{fancyvrb}
\usepackage{syntax}
\usepackage{tikz}

\DefineVerbatimEnvironment{code}{Verbatim}{baselinestretch=.8, samepage=true}

\setmainfont{Garamond Premier Pro}[Contextuals=AlternateOff, Numbers=OldStyle]
\setmathfont{Libertinus Math}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=0.7]

\setlength{\parindent}{1em}
\setlist{noitemsep}

\newcommand{\ttx}{\texttt}

\begin{document}
\begin{code}
module HuttonChap16 where

open import Haskell.Prelude
open import Haskell.Law.Equality using (sym; begin_; _≡⟨⟩_; step-≡; _∎; cong)
open import Haskell.Law.Eq.Def using (IsLawfulEq; eqReflexivity)
open import Haskell.Law.Num.Def using (+-assoc)
\end{code}

\noindent
\textsc{Induction on Numbers}

\noindent
Proving the first fact about replicate:

\begin{code}
replicate : {a : Set} → Nat → a → List a
replicate zero _ = []
replicate (suc n) x = x ∷ replicate n x

len-repl : {A : Set} → (n : Nat) → (x : A) → lengthNat (replicate n x) ≡ n
len-repl zero x = refl
len-repl (suc n) x =
  begin
    lengthNat (replicate (suc n) x)
  ≡⟨⟩ -- Apply replicate
    lengthNat (x ∷ replicate n x)
  ≡⟨⟩ -- Apply lengthNat
    suc (lengthNat (replicate n x))
  ≡⟨ cong suc (len-repl n x) ⟩
    suc n
  ∎
\end{code}

\noindent
Some facts about append:

\begin{code}
++-[] : {a : Set} → (xs : List a) → xs ++ [] ≡ xs
++-[] [] = begin ([] ++ []) ≡⟨⟩ [] ∎
++-[] (x ∷ xs) =
    begin
      (x ∷ xs) ++ []
    ≡⟨⟩ -- Apply ++
      x ∷ (xs ++ [])
    ≡⟨ cong (x ∷_) (++-[] xs) ⟩
      x ∷ xs
    ∎
\end{code}

\begin{code}
++-assoc : {a : Set} → (xs ys zs : List a)
    → (xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)
++-assoc [] ys zs =
    begin
      ([] ++ ys) ++ zs
    ≡⟨⟩ -- Apply ++
      ys ++ zs
    ≡⟨⟩ -- Unapply ++
      [] ++ (ys ++ zs)
    ∎
++-assoc (x ∷ xs) ys zs =
    begin
      ((x ∷ xs) ++ ys) ++ zs
    ≡⟨⟩ -- Apply ++
      (x ∷ (xs ++ ys)) ++ zs
    ≡⟨⟩ -- Apply ++
      x ∷ ((xs ++ ys) ++ zs)
    ≡⟨ cong (x ∷_) (++-assoc xs ys zs) ⟩
      x ∷ (xs ++ (ys ++ zs))
    ≡⟨⟩ -- Unapply ++
      (x ∷ xs) ++ (ys ++ zs)
    ∎
\end{code}

\noindent Hutton's example of elimination of append from flattening a tree:

\begin{code}
data Tree (a : Set) : Set where
    Leaf : a → Tree a
    Node : Tree a → Tree a → Tree a
{-# COMPILE AGDA2HS Tree #-}

flatten : {a : Set} → Tree a → List a
flatten (Leaf x) = x ∷ []
flatten (Node tl tr) = flatten tl ++ flatten tr
{-# COMPILE AGDA2HS flatten #-}

flatten' : {a : Set } → Tree a → List a → List a
flatten' (Leaf x) xs = x ∷ xs
flatten' (Node tₗ tᵣ) xs = flatten' tₗ (flatten' tᵣ xs)
{-# COMPILE AGDA2HS flatten' #-}
\end{code}

\begin{code}
flatten'-flatten : {a : Set} → (t : Tree a) → (xs : List a)
    → flatten' t xs ≡ flatten t ++ xs
flatten'-flatten (Leaf x) xs = refl
flatten'-flatten (Node tₗ tᵣ) xs =
  begin
    flatten' (Node tₗ tᵣ) xs
  ≡⟨⟩ -- Apply flatten'
    flatten' tₗ (flatten' tᵣ xs)
  ≡⟨ cong (flatten' tₗ) (flatten'-flatten tᵣ xs) ⟩
    flatten' tₗ (flatten tᵣ ++ xs)
  ≡⟨ flatten'-flatten tₗ (flatten tᵣ ++ xs) ⟩
    flatten tₗ ++ (flatten tᵣ ++ xs)
  ≡⟨ sym (++-assoc (flatten tₗ) (flatten tᵣ) xs) ⟩
    (flatten tₗ ++ flatten tᵣ) ++ xs
  ≡⟨⟩ -- Unapply flatten
    flatten (Node tₗ tᵣ) ++ xs
  ∎

flatten'-≡-flatten : {a : Set} → (t : Tree a)
    → flatten' t [] ≡ flatten t
flatten'-≡-flatten (Leaf x) = refl
flatten'-≡-flatten (Node tₗ tᵣ) =
  begin
    flatten' (Node tₗ tᵣ) []
  ≡⟨⟩ -- Apply flatten'
    flatten' tₗ (flatten' tᵣ [])
  ≡⟨ cong (flatten' tₗ) (flatten'-flatten tᵣ []) ⟩ -- Apply the above equality
    flatten' tₗ (flatten tᵣ ++ [])
  ≡⟨ flatten'-flatten tₗ (flatten tᵣ ++ []) ⟩ -- Apply it again
    flatten tₗ ++ (flatten tᵣ ++ [])
  ≡⟨ cong (flatten tₗ ++_) (++-[] (flatten tᵣ)) ⟩ -- Remove trailing []
    flatten tₗ ++ flatten tᵣ
  ≡⟨⟩ -- Unapply flatten
    flatten (Node tₗ tᵣ)
  ∎
\end{code}

\noindent
\textsc{Compiler correctness}

\begin{code}
data Expr : Set where
    Val : Int → Expr
    Add : Expr → Expr → Expr
{-# COMPILE AGDA2HS Expr #-}

eval : Expr → Int
eval (Val n) = n
eval (Add x y) = eval x + eval y
{-# COMPILE AGDA2HS eval #-}

Stack = List Int
{-# COMPILE AGDA2HS Stack #-}

data Op : Set where
    PUSH : Int → Op
    ADD : Op
{-# COMPILE AGDA2HS Op #-}
\end{code}

\begin{code}
Code = List Op
{-# COMPILE AGDA2HS Code #-}

exec : Code → Stack → Stack
exec [] s = s
exec (PUSH n ∷ c) s = exec c $ n ∷ s
exec (ADD ∷ c) (m ∷ n ∷ s) = exec c $ n + m ∷ s
exec (ADD ∷ c) _ = []
{-# COMPILE AGDA2HS exec #-}

comp : Expr → Code → Code
comp (Val n) c = PUSH n ∷ c
comp (Add x y) c = comp x $ comp y $ ADD ∷ c
{-# COMPILE AGDA2HS comp #-}

comp-exec-eval : (e : Expr) → (c : Code) → (s : Stack)
    → exec (comp e c) s ≡ exec c (eval e ∷ s)
comp-exec-eval (Val n) c s =
  begin
    exec (comp (Val n) c) s
  ≡⟨⟩ -- Apply comp
    exec (PUSH n ∷ c) s
  ≡⟨⟩ -- Apply exec
    exec c (n ∷ s)
  ≡⟨⟩ -- Unapply eval
    exec c (eval (Val n) ∷ s)
  ∎
comp-exec-eval (Add x y) c s =
  begin
    exec (comp (Add x y) c) s
  ≡⟨⟩ -- Apply comp
    exec (comp x $ comp y $ ADD ∷ c) s
  ≡⟨ comp-exec-eval x (comp y $ ADD ∷ c) s ⟩ -- Induction
    exec (comp y $ ADD ∷ c) (eval x ∷ s)
  ≡⟨ comp-exec-eval y (ADD ∷ c) (eval x ∷ s) ⟩ -- Induction Again
    exec (ADD ∷ c) (eval y ∷ eval x ∷ s)
  ≡⟨⟩ -- Apply exec
    exec c ((eval x) + (eval y) ∷ s)
  ≡⟨⟩ -- Unapply eval
    exec c (eval (Add x y) ∷ s)
  ∎

compile : Expr → Code
compile e = comp e []
{-# COMPILE AGDA2HS compile #-}

compile-exec-eval : (e : Expr) → exec (compile e) [] ≡ eval e ∷ []
compile-exec-eval e =
  begin
    exec (compile e) []
  ≡⟨⟩ -- Apply compile
    exec (comp e []) []
  ≡⟨ comp-exec-eval e [] [] ⟩
    exec [] (eval e ∷ [])
  ≡⟨⟩ -- Apply exec
    eval e ∷ []
  ∎
\end{code}

\noindent
\textsc{Exercise 1.} Show that \verb!add n (Suc m) = Suc (add n m)! by induction on \texttt{n}

\begin{code}
+-suc : (n m : Nat) → n + (suc m) ≡ suc (n + m)
+-suc zero m = refl
+-suc (suc n) m =
  begin
    (suc n) + (suc m)
  ≡⟨⟩ -- Apply +
    suc (n + suc m)
  ≡⟨ cong suc (+-suc n m) ⟩
    suc (suc (n + m))
  ≡⟨⟩ -- Unapply +
    suc (suc n + m)
  ∎
\end{code}

\noindent
\textsc{Exercise 2.} Using this property, together with \texttt{add n zero = n}, show that addition is commutative, \texttt{add n m = add m n}, by induction on \texttt{n}.

\begin{code}
+-zero : (n : Nat) → n + zero ≡ n
+-zero zero = refl
+-zero (suc n) =
  begin
    suc n + zero
  ≡⟨⟩ -- Apply +
    suc (n + zero)
  ≡⟨ cong suc (+-zero n) ⟩
    suc n
  ∎
+-commut : (n m : Nat) → n + m ≡ m + n
+-commut zero m =
  begin
    zero + m
  ≡⟨⟩ -- Apply +
    m
  ≡⟨ sym (+-zero m) ⟩
    m + zero
  ∎
+-commut (suc n) m =
  begin
    suc n + m
  ≡⟨⟩ -- Apply +
    suc (n + m)
  ≡⟨ cong suc (+-commut n m) ⟩
    suc (m + n)
  ≡⟨ sym (+-suc m n) ⟩
    m + suc n
  ∎
\end{code}

\noindent
\textsc{Exercise 3.}
Complete the proof of the correctness of replicate by showing that it produces a list with identical elements, \verb!all (== x) (replicate n x)!, by induction on $n ≥ 0$. Hint: show that the property is always \verb!True!.

\begin{code}
all-repl : ⦃ iEq : Eq a ⦄ → ⦃ IsLawfulEq a ⦄ → (n : Nat) → (x : a)
    → all (_== x) (replicate n x) ≡ True
all-repl zero x = refl
all-repl (suc n) x =
  begin
    all (_== x) (replicate (suc n) x)
  ≡⟨⟩ -- Apply replicate
    all (_== x) (x ∷ replicate n x)
  ≡⟨⟩ -- Apply all
    (x == x) && (all (_== x) (replicate n x))
  ≡⟨ cong ((x == x) &&_) (all-repl n x) ⟩ -- Induction
    (x == x) && True
  ≡⟨ cong (_&& True) (eqReflexivity x) ⟩ -- Reflexivity x == x
    True
  ∎
\end{code}

\noindent
\textsc{Exercise 4.} This is \verb!++-[]! and \verb!++-assoc! above.
\vspace{3pt}

\noindent
\textsc{Exercise 5.} Using the above definition for \texttt{++}, together with the definitions for \texttt{take} and \texttt{drop} show that \verb!take n xs ++ drop n xs! $=$ \verb!xs!, by simultaneous induction on the integer n and the list xs. Hint: there are three cases, one for each pattern of arguments in the definitions of take and drop.

\begin{code}
take-drop-nat : {a : Set} → (n : Nat) → (xs : List a)
    → takeNat n xs ++ dropNat n xs ≡ xs
take-drop-nat n [] = refl
take-drop-nat zero (x ∷ xs) =
  begin
    takeNat zero (x ∷ xs) ++ dropNat zero (x ∷ xs)
  ≡⟨⟩ -- Apply takeNat and dropNat
    [] ++ x ∷ xs
  ≡⟨⟩
    x ∷ xs
  ∎
take-drop-nat (suc n) (x ∷ xs) =
  begin
    takeNat (suc n) (x ∷ xs) ++ dropNat (suc n) (x ∷ xs)
  ≡⟨⟩ -- Apply takeNat and dropNat and ++
    x ∷ takeNat n xs ++ dropNat n xs
  ≡⟨ cong (x ∷_) (take-drop-nat n xs) ⟩
    x ∷ xs
  ∎
take-drop : {a : Set} → (n : Int) → ⦃ iNN : IsNonNegativeInt n ⦄
    → (xs : List a) → take n xs ++ drop n xs ≡ xs
take-drop n xs =
  begin
    take n xs ++ drop n xs
  ≡⟨⟩ -- Apply take and drop
    takeNat (intToNat n) xs ++ dropNat (intToNat n) xs
  ≡⟨ take-drop-nat (intToNat n) xs ⟩
    xs
  ∎
\end{code}

\noindent
\textsc{Exercise 6.} Given the \texttt{Tree} definition above, show that the number of leaves in such a tree is always one greater than the number of nodes, by induction on trees. Hint: start by defining functions that count the number of leaves and nodes in a tree.

\begin{code}
nLeaves : {a : Set} → Tree a → Int
nLeaves (Leaf x) = 1
nLeaves (Node tₗ tᵣ) = nLeaves tₗ + nLeaves tᵣ
{-# COMPILE AGDA2HS nLeaves #-}

nNodes : {a : Set} → Tree a → Int
nNodes (Leaf x) = 0
nNodes (Node tₗ tᵣ) = nNodes tₗ + nNodes tᵣ + 1
{-# COMPILE AGDA2HS nNodes #-}

leaves-nodes : {a : Set} → (t : Tree a)
    → nLeaves t ≡ nNodes t + 1
leaves-nodes (Leaf x) =
  begin
    nLeaves (Leaf x)
  ≡⟨⟩
    1
  ≡⟨⟩
    0 + 1
  ≡⟨⟩
    nNodes (Leaf x) + 1
  ∎
leaves-nodes (Node tₗ tᵣ) =
  begin
    nLeaves (Node tₗ tᵣ)
  ≡⟨⟩
    nLeaves tₗ + nLeaves tᵣ
  ≡⟨ cong (_+ nLeaves tᵣ) (leaves-nodes tₗ) ⟩
    nNodes tₗ + 1 + nLeaves tᵣ
  ≡⟨ cong ((nNodes tₗ + 1) +_) (leaves-nodes tᵣ) ⟩
    nNodes tₗ + 1 + (nNodes tᵣ + 1)
  ≡⟨ {!   !} ⟩
    (nNodes tₗ + 1 + nNodes tᵣ) + 1
  ≡⟨ {!   !} ⟩
    nNodes (Node tₗ tᵣ) + 1
  ∎
\end{code}
\end{document}
  