\documentclass{article}

\usepackage[paperwidth=5.5in,paperheight=8.5in,margin=0.5in,footskip=.25in]{geometry}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{unicode-math}
\usepackage{fancyvrb}
\usepackage{syntax}
\usepackage{tikz}

\DefineVerbatimEnvironment{code}{Verbatim}{baselinestretch=.8, samepage=true}

\setmainfont{Garamond Premier Pro}[Contextuals=AlternateOff, Numbers=OldStyle]
\setmathfont{Libertinus Math}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=0.7]

\setlength{\parindent}{1em}
\setlist{noitemsep}

\newcommand{\ttx}{\texttt}

\begin{document}
\begin{code}
module HuttonChap17 where
open import Haskell.Prelude
open import Haskell.Law.Equality using (sym; begin_; _≡⟨⟩_; step-≡; _∎; cong)
data Expr : Set where
    Val : Int → Expr
    Add : Expr → Expr → Expr
{-# COMPILE AGDA2HS Expr #-}

Stack = List Int
{-# COMPILE AGDA2HS Stack #-}

push : Int → Stack → Stack
push n s = n ∷ s
{-# COMPILE AGDA2HS push #-}

add : Stack → Stack
add [] = []
add (x ∷ []) = []
add (x ∷ y ∷ s) = y + x ∷ s
{-# COMPILE AGDA2HS add #-}

module Naïve where
  eval : Expr → Int
  eval (Val n) = n
  eval (Add eₗ eᵣ) = eval eₗ + eval eᵣ

module DefineEval' where
  open Naïve

  eval'-val : (eval' : Expr → Stack → Stack)
    → (eval'-eval : (e : Expr) → (s : Stack) → eval' e s ≡ eval e ∷ s)
    → (n : Int) → (s : Stack) → eval' (Val n) s ≡ push n s
  eval'-val eval' eval'-eval n s =
    begin
      eval' (Val n) s
    ≡⟨ eval'-eval (Val n) s ⟩ -- Specification
      eval (Val n) ∷ s
    ≡⟨⟩ -- Apply eval
      n ∷ s
    ≡⟨⟩ -- Unapply push
      push n s
    ∎
\end{code}
\begin{code}
  eval'-add : (eval' : Expr → Stack → Stack)
    → (eval'-eval : (e : Expr) → (s : Stack) → eval' e s ≡ eval e ∷ s)
    → (x y : Expr) → (s : Stack)
    → eval' (Add x y) s ≡ add (eval' y (eval' x s))
  eval'-add eval' eval'-eval x y s =
    begin
      eval' (Add x y) s
    ≡⟨ eval'-eval (Add x y) s ⟩ -- Specification
      eval (Add x y) ∷ s
    ≡⟨⟩ -- Apply eval
      eval x + eval y ∷ s
    ≡⟨⟩ -- Unapply add
      add (eval y ∷ eval x ∷ s)
    ≡⟨ cong (λ x → add (eval y ∷ x)) (sym (eval'-eval x s)) ⟩ -- Induction
      add (eval y ∷ eval' x s)
    ≡⟨ cong add (sym (eval'-eval y (eval' x s))) ⟩
      add (eval' y (eval' x s))
    ∎
\end{code}
\begin{code}
eval' : Expr → Stack → Stack
eval' (Val n) s = push n s
eval' (Add eₗ eᵣ) s = add (eval' eᵣ (eval' eₗ s))
{-# COMPILE AGDA2HS eval' #-}

eval'-eval : (e : Expr) → (s : Stack) → eval' e s ≡ Naïve.eval e ∷ s
eval'-eval (Val n) s = refl
eval'-eval (Add x y) s =
  begin
    eval' (Add x y) s
  ≡⟨⟩
    add (eval' y (eval' x s))
  ≡⟨ cong (λ s → add (eval' y s)) (eval'-eval x s) ⟩
    add (eval' y (Naïve.eval x ∷ s))
  ≡⟨ cong add (eval'-eval y (Naïve.eval x ∷ s)) ⟩
    add (Naïve.eval y ∷ Naïve.eval x ∷ s)
  ≡⟨⟩
    Naïve.eval (Add x y) ∷ s
  ∎

open import Haskell.Prim using (NonEmpty; itsNonEmpty)
open import Haskell.Law.Equality using (subst)

eval'-nonempty : (e : Expr) → NonEmpty (eval' e [])
eval'-nonempty e = subst NonEmpty (sym (eval'-eval e [])) itsNonEmpty

eval : Expr → Int
eval e = head (eval' e [])
  where instance
    ne : NonEmpty (eval' e [])
    ne = eval'-nonempty e
{-# COMPILE AGDA2HS eval #-}
\end{code} 
\end{document}
 